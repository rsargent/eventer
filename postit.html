<html>
<head>
<style>
body {
  font-family: arial;
}
#topbar div {
  vertical-align: top;
}
#timer {
  font-size:36px;
  height: 90px;
  background: #ccf;
  display: inline-block;
  padding: 9px;
  width: 100px;
  text-align: center;
}
.postitbar {
  height: 108px;
  vertical-align: top;
}
.postitbar *, #edit { 
  font-size: 14px;
  background: yellow; 
  border-color: black;
  border-style: solid;
  display: inline-block;
  border-width: 1px;
  padding: 3px;
  height: 100px;
  font-family: arial;
  text-align: left;
  word-wrap:break-word;
  white-space: pre-wrap;
}
.postitbar * {
  max-width: 100px;
  min-width: 35px;
  margin-left: 4px;
  margin-right: 4px;
  cursor: default;
}
</style>
<script src="js/jquery-1.7.1.min.js"></script>
<script src="js/jquery-ui-1.8.17.custom.min.js"></script>
<script>

/*!
 * jQuery TextChange Plugin
 * http://www.zurb.com/playground/jquery-text-change-custom-event
 *
 * Copyright 2010, ZURB
 * Released under the MIT License
 */
(function ($) {
	
	$.event.special.textchange = {
		
		setup: function (data, namespaces) {
		  $(this).data('lastValue', this.contentEditable === 'true' ? $(this).html() : $(this).val());
			$(this).bind('keyup.textchange', $.event.special.textchange.handler);
			$(this).bind('cut.textchange paste.textchange input.textchange', $.event.special.textchange.delayedHandler);
		},
		
		teardown: function (namespaces) {
			$(this).unbind('.textchange');
		},
		
		handler: function (event) {
			$.event.special.textchange.triggerIfChanged($(this));
		},
		
		delayedHandler: function (event) {
			var element = $(this);
			setTimeout(function () {
				$.event.special.textchange.triggerIfChanged(element);
			}, 25);
		},
		
		triggerIfChanged: function (element) {
		  var current = element[0].contentEditable === 'true' ? element.html() : element.val();
			if (current !== element.data('lastValue')) {
				element.trigger('textchange',  [element.data('lastValue')]);
				element.data('lastValue', current);
			}
		}
	};
	
	$.event.special.hastext = {
		
		setup: function (data, namespaces) {
			$(this).bind('textchange', $.event.special.hastext.handler);
		},
		
		teardown: function (namespaces) {
			$(this).unbind('textchange', $.event.special.hastext.handler);
		},
		
		handler: function (event, lastValue) {
			if ((lastValue === '') && lastValue !== $(this).val()) {
				$(this).trigger('hastext');
			}
		}
	};
	
	$.event.special.notext = {
		
		setup: function (data, namespaces) {
			$(this).bind('textchange', $.event.special.notext.handler);
		},
		
		teardown: function (namespaces) {
			$(this).unbind('textchange', $.event.special.notext.handler);
		},
		
		handler: function (event, lastValue) {
			if ($(this).val() === '' && $(this).val() !== lastValue) {
				$(this).trigger('notext');
			}
		}
	};	

})(jQuery);

function childrenWidth(elt) {
  var width = 0;
  elt.children().each(function() { 
    width += $(this).outerWidth(true); 
  });
  return width;
}

// idle, running, paused

var timerState = "idle";
var startTimerVal = 25*60;
var timerVal = startTimerVal;
var timerTimeout = null;

// Format a positive number, showing the last two digits
function f2(n) {
  var ret = n + '';
  while (ret.length < 2) ret = '0' + ret;
  return ret;
}

function resetTimerIfIdle() {
  if (timerState == 'idle') {
    timerVal = startTimerVal;
    updateTimer();
  } 
}

function startOrPauseTimer() {
  if (timerState == 'running') {
    console.log('Pause timer');
    if (timerTimeout) clearTimeout(timerTimeout);
    timerState = 'paused';
  } else {
    if (timerState == 'idle') {
      timerVal = startTimerVal;
      console.log('Start timer');
    } else {
      console.log('Unpause timer');
    }
    lastTickTime = new Date().getTime();
    timerTimeout = setTimeout(timerTick, 1000);
    timerState = 'running';
  }
  updateTimer();
}

function abortTimer() {
  if (timerState == 'idle') return;
  console.log('Abort timer');
  timerState = 'idle';
  if (timerTimeout) clearTimeout(timerTimeout);
  timerVal = startTimerVal;
  updateTimer();
}

function updateTimer() {
  $('#timerval').html(f2(Math.floor(timerVal / 60)) + ':' + f2(timerVal % 60));
  if (timerState == 'idle') $('#startpause').html('Start');
  if (timerState == 'paused') $('#startpause').html('Unpause');
  if (timerState == 'running') $('#startpause').html('Pause');
}

function timerTick() {
  if (timerState != 'running') return;
  // How many ticks have elapsed?
  var now = new Date().getTime();
  // OK to count up to 10 ticks, not more.  More probably means the computer slept or the clock time changed
  var ticksElapsed = Math.floor((now + 100 - lastTickTime) / 1000);
  if (ticksElapsed > 10) {
    ticksElapsed = 10;
    lastTickTime = now;
  } else {
    lastTickTime += ticksElapsed * 1000;
  }
  timerVal -= ticksElapsed;
  if (timerVal <= 0) {
    timerVal = 0;
    timerState = 'idle';
    console.log('Timer done');
    setTimeout(resetTimerIfIdle, 2500);
  } else {
    timerTimeout = setTimeout(timerTick, 1000 - now + lastTickTime);
  }
  updateTimer();
}

function updateTopbar() {
  var fixed=[];
  var variable=[];
  var width_used = 0;
  var nelastic = 0;
  $('#topbar .elastic').each(function() {
    nelastic++;
    width_used += childrenWidth($(this));
  });
  $('#topbar .inelastic').each(function() {
    width_used += $(this).outerWidth(true);
  });
  var total = $('#topbar').innerWidth();
  var margin = total - width_used;

  $('#topbar .elastic').each(function() {
    $(this).css('width', childrenWidth($(this)) + margin / nelastic);
  });
}
function updateEdit() {
  editingDiv.text($('#edit').val());
  $('#edit').css(editingDiv.offset())
            .width(editingDiv.outerWidth())
            .height(editingDiv.outerHeight())
            .show();
}
var editingDiv = null;
function textchange() {
  console.log('textchange');
}
function startEdit(elt) {
  console.log("startedit");
  editingDiv = elt;
  console.log('Edit ' + editingDiv);
  $('#edit').val(editingDiv.text());
  updateEdit();
  $('#edit')[0].focus();
  $('#edit')[0].select();
  $('#edit').bind('textchange', updateEdit);
}
function endEdit() {
  $('#edit').hide();
}

// Return finishes edit, unless shift or alt are pressed, in which case a newline is inserted
// Apps that use return to finish edit, or shift-return to insert newline:
//    AIM, Google talk, Microsoft Word or google docs, when editing a bullet in a bulleted list
// Apps that use return to finish edit, or alt-return (option-return on mac) to insert newline:
//    Excel on Windows.  (Excel on Mac uses option-command-return, yuk)
function editKeypress(e) {
  if (e.which == 13 && !e.shiftKey && !e.altKey) {
    e.preventDefault();
    endEdit();
  }
}
function init() {
  $('.postitbar').sortable({
                     connectWith: '.postitbar', 
                     containment: '#topbar', 
                     tolerance: 'pointer',
                     scroll: false,
                     update: updateTopbar
                           });
  $('#topbar').disableSelection();
  $(window).resize(updateTopbar);
  $('#startpause').click(startOrPauseTimer);
  $('#abort').click(abortTimer);
  $('.postitbar *').dblclick(function(){startEdit($(this));});
  updateTopbar();
  updateTimer();
  $('#edit').keypress(editKeypress);
  $('body').mousedown(function(e){if (e.target.id != 'edit') endEdit();});
}
$(init);
</script>
</head>
<body>
<table style="width:100%"><tr id="topbar" style="height: 100px">
<td id="timer" class="inelastic">
<span id='timerval'></span><br>
<button id='startpause'>Start</button><br>
<button id='abort'>Abort</button>
</td>
<td id="postitbar0" class="postitbar elastic" style="display:inline-block; background:#fcc;">
<div>Edit postit</div>
<div>Add postit</div>
</td>
<td id="postitbar1" class="postitbar elastic" style="display:inline-block; text-align: right; background:#cfc;">
<div>Auto-resize two location divs to make swapping between locations easier</div>
<div>Relayout with pomodoro timer</div>
<div>Two locations on the top bar</div>
</td>
</tr>
</table>
<textarea spellcheck="false" id="edit" style="position:absolute; display:none"></textarea>
</body>
</html>
